#!/usr/bin/env python3

from time import sleep, time

from ev3dev2.motor import LargeMotor, MediumMotor, OUTPUT_A, OUTPUT_B, OUTPUT_D, SpeedPercent

from ev3dev2.sensor import INPUT_1, INPUT_3, INPUT_4
from ev3dev2.sensor.lego import TouchSensor, ColorSensor

MAX_TURN_SPEED = 25
MAX_SPEED = 50

color_left = ColorSensor(INPUT_1)
color_right = ColorSensor(INPUT_4)
touch = TouchSensor(INPUT_3)

left_motor = LargeMotor(OUTPUT_A)
right_motor = LargeMotor(OUTPUT_B)
hook = MediumMotor(OUTPUT_D)

base_speed = 20
turn_multiplier = 0.5
step = 0.01
rotate_time = 1

def is_black(sensor):
    return sensor.color == ColorSensor.COLOR_BLACK

def is_color(sensor, color):
	return sensor.color == color


def rotate_left_easy(speed, time):
	left_motor.on(SpeedPercent(-speed))
	right_motor.on(SpeedPercent(0))
	sleep(time)


def rotate_right_easy(speed, time):
	left_motor.on(SpeedPercent(0))
	right_motor.on(SpeedPercent(-speed))
	sleep(time)

def go_back(speed, time):
	left_motor.on(SpeedPercent(-speed))
	right_motor.on(SpeedPercent(-speed))
	sleep(time)
	
def rotate_90(color, is_right):
	pass

def pick_up_object(color):
	# drive fwd, raise object, turn 180, drive to edge
	pass

def drop_off_object(color):
	# drive fwd, lower object, turn 180, drive to edge
	pass
	
def pick_up_color(is_right):
	color = ColorSensor.COLOR_GREEN
	rotate_90(color, is_right)
	follow_line(color)
	pick_up_object(color)
	follow_line(color)
	rotate_90(ColorSensor.COLOR_BLACK, is_right=True)
	
def drop_off_color(is_right):
	color = ColorSensor.COLOR_RED
	rotate_90(color, is_right)
	follow_line(color)
	drop_off_object(color)
	follow_line(color)
	rotate_90(ColorSensor.COLOR_BLACK, is_right=True)
	
	
def follow_line(color):
	straight_counter = 30
	speed = 20
	while True:
		if touch.is_pressed:
			sleep(0.5)
			return False
		if color == ColorSensor.COLOR_BLACK:
			left_black = is_black(color_left)
			right_black = is_black(color_right)
		else:
			left_black = is_color(color_left, color)
			right_black = is_color(color_right, color)
	
		print("\nCOLORS:")
		print(color_left.color)
		print(color_right.color)

		if straight_counter > 30:
			speed = 2 * base_speed # prędkość na prostych
		else:
			speed = base_speed # prędkość na zakrętach
		

		if not left_black and not right_black:
			# stan jedź prosto
			straight_counter += 1
			left_motor.on(SpeedPercent(speed))
			right_motor.on(SpeedPercent(speed))
			sleep(step * 0.3) 

		else:
			if straight_counter > 30:
				speed = base_speed
				if left_black and not right_black:
					rotate_left_easy(speed, step * 5)
				elif right_black and not left_black:
					rotate_right_easy(speed, step * 5)
				go_back(speed, step * 30)
				
			elif straight_counter > 5:
				speed = base_speed
				go_back(speed, step * 5)

			straight_counter = 0
			speed = base_speed
			# stan na zakręcie
			if left_black and not right_black:
				# Czarna linia po lewej – skręć w lewo
				rotate_left_easy(speed, step * 5)


			elif right_black and not left_black:
				# Czarna linia po prawej – skręć w prawo
				rotate_right_easy(speed, step * 5)
				
			else:
				# skrzyżowanie lub prosto na łuku
				left_motor.on(SpeedPercent(speed))
				right_motor.on(SpeedPercent(speed))
				sleep(step * 10)


def run():
	running = False
	if touch.is_pressed:
		running = True
		sleep(0.5)
	while running:
		running = follow_line(ColorSensor.COLOR_BLACK)
    

# def measure_rotate_time():
# 	speed = 20
# 	start = time()
# 	sleep(0.5)
# 	left_motor.on(SpeedPercent(-speed))
# 	right_motor.on(SpeedPercent(speed))
# 	if is_black(color_left) and is_black(color_right):
# 		stop = time()
# 		print("time elapsed: ", stop-start)
# 		left_motor.off()
# 		right_motor.off()

running = False
print("READY")
while True:
	left_motor.off()
	right_motor.off()
	hook.off()
	run()
